syntax = "proto3";

package remotesigner;

// Phase 1 API
// -----------
//
// In this phase, transactions are provided in serialized form to the signer.  There is also a somewhat
// redundant passing of channel-constant values into specific signing requests.
//
// In phase 2, transactions will be constructed on the signer from detailed information, such as amounts,
// to_self_delay, etc. .  See the Phase 2 section near the end of this file for a sketch.

service Signer {
  // Trivial call to test connectivity
  rpc Ping(PingRequest)
    returns (PingReply);

  // Provision a signer for a new node
  rpc Init (InitRequest)
    returns (InitReply);

  // BOLT #2 - Peer Protocol
  rpc NewChannel (NewChannelRequest)
    returns (NewChannelReply);

  // BOLT #2 - Channel Close
  rpc SignMutualCloseTx (SignMutualCloseTxRequest)
    returns (SignatureReply);

  // BOLT #2 - Message Retransmission
  rpc CheckFutureSecret (CheckFutureSecretRequest)
    returns (CheckFutureSecretReply);
  
  // BOLT #3 - Key Derivation
  rpc GetChannelBasepoints (GetChannelBasepointsRequest)
    returns (GetChannelBasepointsReply);
    
  // BOLT #3 - Per-commitment Secret Requirements
  rpc GetPerCommitmentPoint (GetPerCommitmentPointRequest)
    returns (GetPerCommitmentPointReply);

  // BOLT #3 - Funding Transaction
  rpc SignFundingTx (SignFundingTxRequest)
    returns (SignFundingTxReply);
    
  // BOLT #3 - Commitment Transaction
  rpc SignRemoteCommitmentTx (SignRemoteCommitmentTxRequest)
    returns (SignatureReply);

  // BOLT #3 - Commitment Transaction
  rpc SignCommitmentTx (SignCommitmentTxRequest)
    returns (SignatureReply);
    
  // BOLT #3 - HTLC Outputs
  rpc SignLocalHTLCTx (SignLocalHTLCTxRequest)
    returns (SignatureReply);
    
  // BOLT #5 - Unilateral Close Handling
  rpc SignDelayedPaymentToUs (SignDelayedPaymentToUsRequest)
    returns (SignatureReply);
    
  // BOLT #3 - HTLC Outputs
  rpc SignRemoteHTLCTx (SignRemoteHTLCTxRequest)
    returns (SignatureReply);

  // BOLT #3 - HTLC Outputs
  rpc SignRemoteHTLCToUs (SignRemoteHTLCToUsRequest)
    returns (SignatureReply);
    
  // BOLT #5 - Unilateral Close Handling
  rpc SignPenaltyToUs (SignPenaltyToUsRequest)
    returns (SignatureReply);

  // BOLT #7 - channel_announcement
  rpc SignChannelAnnouncement (SignChannelAnnouncementRequest)
    returns (SignChannelAnnouncementReply);

  // BOLT #7 - node_announcement
  rpc SignNodeAnnouncement (SignNodeAnnouncementRequest)
    returns (NodeSignatureReply);

  // BOLT #7 - channel_update
  rpc SignChannelUpdate (SignChannelUpdateRequest)
    returns (NodeSignatureReply);

  // BOLT #8 - Authenticated Key Agreement Handshake
  rpc ECDH (ECDHRequest)
    returns (ECDHReply);

  // BOLT #11 - Invoice Protocol
  rpc SignInvoice (SignInvoiceRequest)
    returns (RecoverableNodeSignatureReply);

  // BOLT #?? - Sign Message
  rpc SignMessage (SignMessageRequest)
    returns (RecoverableNodeSignatureReply);
}

service Version {
  // Get detailed version information
  rpc Version (VersionRequest) returns (VersionReply);
}

// ----------------------------------------------------------------

message PingRequest {
  string message = 1;
}

message PingReply {
  string message = 1;
}

// Initialize a new Lightning node
message InitRequest {
  ChainParams chainparams = 1;

  // Developer field: set the HSM secret rather than generate it on
  // the signer side. Only allowed if this is using a non-production
  // network.
  Secret hsm_secret = 100;
}

message InitReply {
  NodeId node_id = 1;
}

// Initialize a new channel
// TODO provide remote keys and basepoints in a new ChannelAccepted call
message NewChannelRequest {
  NodeId node_id = 1;

  // optional, will be pseudo-randomly generated if missing
  ChannelNonce channel_nonce = 2;

  // in satoshis
  uint64 channel_value = 3;

  // Local to_self_delay
  uint32 to_self_delay = 4;
  // Local shutdown Bitcoin script used when closing the channel
  bytes shutdown_script = 5;
}

message NewChannelReply {
  ChannelNonce channel_nonce = 1;
}

// Sign a happy path mutual close transaction
message SignMutualCloseTxRequest {
  NodeId node_id = 1;
    
  ChannelNonce channel_nonce = 2;

  Transaction tx = 3;

  // Deprecated, should be provided in ChannelAcceptedRequest
  PubKey remote_funding_pubkey = 4;
}

message SignatureReply {
  BitcoinSignature signature = 1;
}

// Check if the remote really knows a secret that we haven't generated
// since being restored from backup.  This proves to us that the state
// of the channel is at least at commitment number `n + 1`
message CheckFutureSecretRequest {
  NodeId node_id = 1;

  ChannelNonce channel_nonce = 2;

  // commitment number
  uint64 n = 3;

  // our secret that we haven't generated since being restored from
  // backup, but the remote claims is part of our shachain
  Secret suggested = 4;
}

message CheckFutureSecretReply {
  bool correct = 1;
}

// Get the basepoints and public keys specific to an accepted channel
message GetChannelBasepointsRequest {
  NodeId node_id = 1;
    
  ChannelNonce channel_nonce = 2;
}

message GetChannelBasepointsReply {
  Basepoints basepoints = 1;
}

// Get the per-commitment point for a specific commitment number
message GetPerCommitmentPointRequest {
  NodeId node_id = 1;
    
  ChannelNonce channel_nonce = 2;

  // commitment number
  uint64 n = 3;
}

message GetPerCommitmentPointReply {
  PubKey per_commitment_point = 1;

  // The revocation of the secret of the n-2 commitment, or None if n < 2
  Secret old_secret = 2;
}

// Sign a funding tx for this channel
// The channel must have been accepted
message SignFundingTxRequest {
  NodeId node_id = 1;
  
  ChannelNonce channel_nonce = 2;

  Transaction tx = 3;
}

message SignFundingTxReply {
  // A witness stack for each of our inputs.  For inputs that are not
  // ours, the element is None.
  repeated WitnessStack witnesses = 1;
}

// Sign the remote commitment
message SignRemoteCommitmentTxRequest {
  NodeId node_id = 1;
  
  ChannelNonce channel_nonce = 2;

  // TODO deprecate these two and move to specifying all the
  // information that is required to rebuild the tx
  Transaction tx = 3;

  // TODO deprecate the next three fields and move to ChannelAccepted
  PubKey remote_funding_pubkey = 4;

  PubKey remote_per_commit_point = 5;

  bool option_static_remotekey = 7;
}

// Force close a channel by signing a local commitment tx.  The
// channel moves to closing state.
message SignCommitmentTxRequest {
  NodeId node_id = 1;
  
  ChannelNonce channel_nonce = 2;
    
  Transaction tx = 3;
  
  // TODO deprecate and move to ChannelAccepted
  PubKey remote_funding_pubkey = 4;
}

// As part of a force close, sweep a local HTLC output hanging off the
// commitment tx
message SignLocalHTLCTxRequest {
  NodeId node_id = 1;

  ChannelNonce channel_nonce = 2;

  Transaction tx = 3;

  uint64 n = 4;
}

// As part of a force close, sweep the delayed to local output hanging
// off the commitment tx
message SignDelayedPaymentToUsRequest {
  NodeId node_id = 1;
    
  ChannelNonce channel_nonce = 2;

  Transaction tx = 3;
  
  uint64 n = 4;
}

// Sign a remote HTLC tx hanging off the remote commitment tx
message SignRemoteHTLCTxRequest {
  NodeId node_id = 1;

  ChannelNonce channel_nonce = 2;

  Transaction tx = 3;

  PubKey remote_per_commit_point = 4;
}

// Sweep a remote HTLC to us
message SignRemoteHTLCToUsRequest {
  NodeId node_id = 1;

  ChannelNonce channel_nonce = 2;

  Transaction tx = 3;

  PubKey remote_per_commit_point = 4;
}

// Sign a penalty sweep of a remote to_local the peer has revoked
message SignPenaltyToUsRequest {
  NodeId node_id = 1;
    
  ChannelNonce channel_nonce = 2;

  Transaction tx = 3;

  Secret revocation_secret = 4;	// FIXME - is this remembered instead of passed?
}

// Sign a channel announcement
message SignChannelAnnouncementRequest {
  NodeId node_id = 1;
  
  ChannelNonce channel_nonce = 2;

  // Channel announcement message in BOLT-7 serialization
  bytes channel_announcement = 3;
}

message SignChannelAnnouncementReply {
  ECDSASignature node_signature = 1;

  ECDSASignature bitcoin_signature = 2;
}

// Sign node announcement message
message SignNodeAnnouncementRequest {
  NodeId node_id = 1;

  // announcement message in BOLT-7 format
  bytes node_announcement = 2;
}

message NodeSignatureReply {
  ECDSASignature signature = 1;
}

// Sign channel update message
message SignChannelUpdateRequest {
  // https://github.com/lightningnetwork/lightning-rfc/blob/master/07-routing-gossip.md#the-channel_update-message
  
  NodeId node_id = 1;

  // Portion of the channel_update message which requires signing
  // (skip the message type and the signature field, 66 byte offset).
  // In BOLT-7 format
  bytes channel_update = 2;
}

// Perform ECDH for p2p communication purposes
message ECDHRequest {
  NodeId node_id = 1;

  // The ephemeral pubkey of the peer
  PubKey point = 2;
}

message ECDHReply {
  Secret shared_secret = 1; // 32 bytes
}

// Sign an invoice with the node secret key
message SignInvoiceRequest {
  NodeId node_id = 1;

  bytes data_part = 2;

  string human_readable_part = 3;
}

message RecoverableNodeSignatureReply {
  ECDSARecoverableSignature signature = 1;
}

// Sign an ad-hoc message with the node secret key
message SignMessageRequest {
  NodeId node_id = 1;

  bytes message = 2;
}

message VersionRequest {
}

message VersionReply {
  string version_string = 1;
  uint32 major = 2;
  uint32 minor = 3;
  uint32 patch = 4;
  string prerelease = 5;
  string build_metadata = 6;
}

// ----------------------------------------------------------------

// Specify the network (e.g. testnet, mainnet)
message ChainParams {
  string network_name = 1;
}

// Compressed ECDSA public key in DER format derived from the node secret
message NodeId {
  bytes data = 1;
}

// A client-side unique ID for the channel, not necessarily related to
// the BOLT temporary/permanent node ID
message ChannelNonce {
  bytes data = 1;
}

// Compressed ECDSA public key in DER format
message PubKey {
  bytes data = 1;
}

// 256-bit Secret, 32 bytes
// Can be used for revocation hash pre-image, shared secrets, etc.
message Secret {
  bytes data = 1;
}

// A Bitcoin serialized transaction with additional metadata if needed
// for signing and validation
message Transaction {
  // The raw bytes of the transaction to be signed.
  bytes raw_tx_bytes = 1;

  // Inner witness program for each output.
  // Empty for p2pkh outputs.
  repeated bytes output_witscripts = 6;

  // A set of sign descriptors, for each input to be signed.
  // TODO the input amount for the commitment tx should be specified
  // in NewChannel instead of here
  repeated SignDescriptor input_descs = 2;
  
  // A set of sign descriptors, for each output.
  repeated SignDescriptor output_descs = 3;
}

// Basepoints and funding pubkey for one side of a channel
message Basepoints {
  PubKey revocation = 1;
  PubKey payment = 2;
  PubKey htlc = 3;
  PubKey delayed_payment = 4;
  PubKey funding_pubkey = 5;
}

// DER encoded SECP256K1_ECDSA Signature
message ECDSASignature {
  bytes data = 1;
}

// Compact ECDSA signature (64 bytes) + recovery id (1 byte) = 65 bytes
message ECDSARecoverableSignature {
  bytes data = 1;
}

// DER encoded Bitcoin Signature
message BitcoinSignature {
  bytes data = 1;
}

// Witness stack item, for signing a segwit transaction
message WitnessStack {
  repeated bytes item = 1;
}

// ----------------------------------------------------------------

message KeyLocator {
  /// The index of the key being identified.
  int32 key_index = 2;
}

// A Bitcoin transaction output
message TxOut {
  /// The value of the output being spent.
  int64 value = 1;

  /// The script of the output being spent.
  bytes pk_script = 2;
}

message SignDescriptor {
  /**
     A descriptor that precisely describes *which* key to use for
     signing. This may provide the raw public key directly, or require
     the Signer to re-derive the key according to the populated
     derivation path.
  */
  KeyLocator key_loc = 1;

  // A description of the output being spent. The value and script
  // MUST be provided.
  TxOut output = 5;
}

// PHASE 2 messages
// ----------------

// These messages will be used in an updated API that constructs and
// signs the commitment and HTLC transactions from elementary info,
// rather than sending the serialized transaction on the wire.

// Information required to create HTLC output and a follow-up HTLC transaction
message HTLCInfo {
  uint64 value = 1;
  bytes payment_hash = 2;
  uint32 cltv_expiry = 3;
}

// Information required to construct a commitment transaction
message CommitmentInfo {
  uint32 feerate_per_kw = 1;
  uint64 n = 2;
  uint64 dust_limit = 3;
  uint64 value_to_local = 4;
  uint64 value_to_remote = 5;
  PubKey per_commitment_point = 6;
  repeated HTLCInfo offered_htlcs = 10;
  repeated HTLCInfo received_htlcs = 11;
}

// Provide information from the remote peer
message ChannelAcceptedRequest {
  Basepoints basepoints = 1;
  uint32 to_self_delay = 2;
  bytes shutdown_script = 3;
}
